<6일차>
- Queue
	- stack과 마찬가지로 제한된 유한순서 자료구조
	- 데이터입력(enqueue)과 삭제(dequeue)가 한쪽 입구에서는 입력, 다른 한쪽 입구에서는 삭제가 이루어진다
	- 가장 먼저 들어온 데이터를 가장 먼저 삭제하는 구조(FIFO : Fist In First Out(선입선출 구조))
	- 구조
		1. front : 가장 먼저 들어온 데이터를 가리키는 역할
		2. rear : 가장 나중에 들어온 데이터를 가리키는 역할
	-순차 큐
		- 1차원 배열을 이용한 큐
			1. 큐의 크기 : 배열의 크기
			2. 변수 front : 저장된 첫번째 원소의 인덱스 저장
			3. 변수 rear : 저장된 마지막 원소의 인덱스 저장

	- 상태
		1. 초기상태 : front == rear == -1
		2. 공백상태 : front == rear
		3. 포화상태 : rear = n-1
	- 알고리즘

	- 순차큐의 문제점
		- 순차큐의 잘못된 포화상태 인식 : 삽입과 삭제가 반복되면서 앞부분에 자리가 비어 있더라도 rear = size-1 상태이므로 포화상태로 인식

	- 해결방법
		1. 저장됨 원소들을 배열의 앞부분으로 이동시키기
		2. 원형 큐 이용

- 원형큐의 구조
	- 초기상태 : front == rear == 0
	- front와 rear의 위치가 배열의 마지막 인덱스 n-1에서 논리적인 다음 자리인 인덱스 0번지로 이동하기 위해서 나머지 연산 사용
 	  단, 공백상태와 포화상태를 구분하기 위해서 front가 있는 자리는 사용하지 않고 항상 빈자리로 둔다

	 순차큐  rear = rear+1				front = front+1
	 원형큐  rear = (rear+1) mod n		  	front = (front+1) mod n

- 연결큐
	- 단순 연결리스트를 이용한 큐
		1. 큐의 원소 : 단순연결 리스트의 노드
		2. 큐의 원소의 순서 : 노드의 링크포인터로 연결
		3. 변수 front : 첫번째 노드를 가리키는 포인터변수
		4. 변수 rear : 마지막 노드를 가리키는 포인터변수

	- 상태표현
		초기상태와 공백상태 : front == rear == null

	- 알고리즘


데크
	- 알고리즘